import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { BehaviorSubject, Observable, of, throwError } from 'rxjs';
import { delay } from 'rxjs/operators';
import { isPlatformBrowser } from '@angular/common';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import {
  RegisterRequest,
  LoginRequest,
  ForgotPasswordRequest,
  LoginResponse,
  RegisterResponse,
} from '../../models/interfaces/user.interface';
import { AccountType } from '../../models/enums/account-type.enum';
import meta from '../../../stories/login.stories';

export interface MockUser {
  // for mock user
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  token: string;
}

export interface ForgotPasswordResponse {
  success: boolean;
  message: string;
  resetToken?: string;
}

export interface ResetPasswordData {
  token: string;
  newPassword: string;
  confirmPassword: string;
}

// Add this interface for the activation response
export interface ActivationResponse {
  status: string;
  code: number;
  message: string;
  data: any;
  meta?: any;
  requestId?: string;
  timestamp?: string;
}

@Injectable({
  providedIn: 'root',
})
export class Auth {
  // backend base path
  private baseUrl = 'api/';

 private httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

  // Hold current user state
  // when http require here we can add http
  private userSubject = new BehaviorSubject<MockUser | null>(
    this.getUserFromStorage(),
  );
  user$ = this.userSubject.asObservable();

  // Mock storage for reset tokens (in real app, this would be handled by backend)
  private resetTokens = new Map<
    string,
    { token: string; expires: Date; email: string }
  >();

  constructor(
    @Inject(PLATFORM_ID) private platformId: Object,
    private http: HttpClient,
  ) {}

  /** Forget password */
  forgotPassword(email: string): Observable<ForgotPasswordResponse> {
    // mock logic
    const useMock = true; // set to `true` to use local mock logic

    if (useMock) {
      // creating mock user to check if email exists
      const existingUserEmail = 'existing@example.com';
      if (email == existingUserEmail) {
        return of({
          success: true,
          message: 'Password reset link has been sent to your email',
          resetToken: this.generateResetToken(email),
        }).pipe(delay(800)); // Simulate network delay
      } else {
        return throwError(() => new Error('Email not found')).pipe(delay(500));
      }
    }

    // real API integration
    const url = `${this.baseUrl}/users/request-password-reset/`;
    const payload: ForgotPasswordRequest = { email };
    return this.http.post<ForgotPasswordResponse>(url, payload, this.httpOptions);
  }

  /** Generate a mock reset token (in real app, this would be generated by backend) */
  /* when real api add this will be remove */
  private generateResetToken(email: string): string {
    const token =
      Math.random().toString(36).substring(2) + Date.now().toString(36);
    const expires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour expiration

    this.resetTokens.set(token, {
      token,
      expires,
      email,
    });

    // Simulate sending email (console log for demo)
    console.log(
      `Password reset link: http://localhost:4200/reset-password?token=${token}`,
    );
    console.log(`Email sent to: ${email}`);

    return token;
  }

  /** Validate reset token */
  private validateResetToken(token: string): { email: string } | null {
    const tokenData = this.resetTokens.get(token);

    if (!tokenData || tokenData.expires < new Date()) {
      return null;
    }

    // Clean up expired tokens
    this.resetTokens.delete(token);

    return { email: tokenData.email };
  }

  /** Clean up expired tokens periodically */
  cleanupExpiredTokens(): void {
    const now = new Date();
    this.resetTokens.forEach((value, key) => {
      if (value.expires < now) {
        this.resetTokens.delete(key);
      }
    });
  }

  /** login */
  login(email: string, password: string): Observable<any> {
    //  **Success Case:** Correct credentials
    if (email === 'user@example.com' && password === 'password123') {
      const mockUser: LoginResponse = {
        aceessToken: 'mock-jwt-token',
        tokenType: 'Bearer',
        expiresIn: 3600,
        userId: '1',
        email,
        firstName: 'Demo',
        lastName: 'User',
        accountType: AccountType.Standard,
        createdAt: new Date().toISOString(),
        date_joined: new Date().toISOString(),
      };

      // Simulate a successful response (200 OK)
      return of({
        status: 200,
        message: 'Login successful',
        data: mockUser,
        meta: {
          requestId: this.generateRequestId(),
          timestamp: new Date().toISOString(),
        },
      }).pipe(delay(500)); // simulate network delay
    } else if (email === 'user@example.com' && password !== 'password123') {
      // Simulate a 401 Unauthorized error for incorrect password
      return throwError(() => ({
        status: 401,
        error: {
          message: 'Unauthorized: Incorrect password',
        },
      })).pipe(delay(500)); // simulate network delay
    }

    //  **Error Case:** Incorrect password or non-existent user
    else {
      // Simulate a 401 Unauthorized error
      return throwError(() => ({
        status: 401,
        error: {
          message: 'Unauthorized: Invalid email or password',
        },
      })).pipe(delay(500)); // simulate network delay
    }

    // real API integration
    const url = `${this.baseUrl}/auth/login/`;
    const payload: LoginRequest = { email, password };
    return this.http.post<LoginResponse>(url, payload , this.httpOptions);
  }

  /** registration */
  register(formData: any): Observable<any> {
    // mock logic
    const emailExists = formData.email === 'existing@example.com'; // Example condition

    if (emailExists) {
      // Simulate 400 error for existing email
      return throwError(() => ({
        status: 400,
        error: {
          message: 'Email already exists',
        },
      })).pipe(delay(700));
    }

    // Simulate successful registration (201)
    const newUser: RegisterResponse = {
      userId: '2',
      aceessToken: 'mock-jwt-token',
      tokenType: 'Bearer',
      expiresIn: 3600,
      firstName: formData.firstName,
      lastName: formData.lastName,
      email: formData.email,
      accountType: AccountType.Standard,
      createdAt: new Date().toISOString(),
      date_joined: new Date().toISOString(),
    };

    // Return response with status code
    return of({
      status: 201,
      message: 'Signup successful. Please verify your email',
      data: newUser,
      meta: {
        requestId: this.generateRequestId(),
        timestamp: new Date().toISOString(),
      },
    }).pipe(delay(700));

    // real api
    const url = `${this.baseUrl}/auth/register/`;
    return this.http.post<any>(url, formData, this.httpOptions);
  }

  // Add this method for resending activation link
  resendActivationLink(email: string): Observable<ActivationResponse> {
    // Simulate different responses based on email
    const isAlreadyActivated = email === 'activated@example.com'; // Example condition

    if (isAlreadyActivated) {
      // Simulate 400 error for already activated account
      return throwError(() => ({
        status: 'error',
        code: 400,
        message: 'Account already activated',
        data: {},
        meta: {},
        requestId: this.generateRequestId(),
        timestamp: new Date().toISOString(),
      })).pipe(delay(700));
    }

    // Simulate successful resend (200)
    return of({
      status: 'success',
      code: 200,
      message: 'Activation link resent successfully',
      data: {},
      meta: {},
      requestId: this.generateRequestId(),
      timestamp: new Date().toISOString(),
    }).pipe(delay(700));

    // real api
    const url = `${this.baseUrl}/auth/resend-activation/`;
    return this.http.post<ActivationResponse>(url, { email });
  }

  // Helper method to generate request ID
  // temporary id generator
  private generateRequestId(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
      /[xy]/g,
      function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      },
    );
  }

  /** Log out the user */
  logout() {
    this.clearSession();
    this.userSubject.next(null);

    // real api
    const url = `${this.baseUrl}/auth/logout/`;
    return this.http.post<any>(url, { }, this.httpOptions);

  }

  /** Get currently logged in user */
  getCurrentUser(): MockUser | null {
    return this.userSubject.value;
  }

  /** Whether user is logged in */
  isLoggedIn(): boolean {
    return !!this.getCurrentUser();
  }

  // Session helpers (localStorage + cookie)
  private setSession(user: MockUser) {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.setItem('currentUser', JSON.stringify(user));

      // Set cookie (expires in 7 days)
      const d = new Date();
      d.setTime(d.getTime() + 7 * 24 * 60 * 60 * 1000);
      document.cookie = `token=${user.token};expires=${d.toUTCString()};path=/`;
    }
    this.userSubject.next(user);
  }

  /** Get user from localStorage */
  private getUserFromStorage(): MockUser | null {
    if (isPlatformBrowser(this.platformId)) {
      const json = localStorage.getItem('currentUser');
      if (json) {
        try {
          return JSON.parse(json) as MockUser;
        } catch {
          return null;
        }
      }
    }
    return null;
  }

  private clearSession() {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem('currentUser');
      this.clearCookie('token');
    }
  }

  /**
   * Clear a specific cookie by name
   */
  private clearCookie(name: string) {
    if (isPlatformBrowser(this.platformId)) {
      // Only available in the browser
      document.cookie = name + '=; Max-Age=0; path=/;';
    }
  }
}
